import { SharedPoolMath } from "./index.js";
import { Fraction, type TFractionLike } from "@sundaeswap/fraction";

export function liquidityInvariant(
  assetA: bigint,
  assetB: bigint,
  linearAmplification: bigint,
  newSumInvariant: bigint,
) {
  // 4 * A * 4 * (x*y) * D + D^3 - (4(x*y) * (4A(x + y) + D))
  // 4A * 4xy * D + D^3 - (4xy * 4a * (x + y) + 4xy * D)
  // 16Axy * D + D^3 - (16Axy * (x + y) + 4xy * D)
  const four_a = 4n * linearAmplification;
  const four_x_y = 4n * assetA * assetB;
  const d_plus_one = newSumInvariant + 1n;
  const d_cubed = newSumInvariant * newSumInvariant * newSumInvariant;
  const d_plus_one_cubed = d_plus_one * d_plus_one * d_plus_one;
  const x_plus_y = assetA + assetB;
  const sixteen_a_x_y = four_a * four_x_y;
  const sixteen_a_x_y_x_plus_y = sixteen_a_x_y * x_plus_y;
  const f1 =
    sixteen_a_x_y * newSumInvariant +
    d_cubed -
    (sixteen_a_x_y_x_plus_y + four_x_y * newSumInvariant);
  const f2 =
    sixteen_a_x_y * d_plus_one +
    d_plus_one_cubed -
    (sixteen_a_x_y_x_plus_y + four_x_y * d_plus_one);
  return f1 <= 0n && f2 > 0n;
}

export const aPrecision = 200n;
export const reservePrecision = 1_000_000_000_000n;

export function getSumInvariant(a: bigint, x: bigint, y: bigint): bigint {
  if (a <= 0n) {
    throw new Error("Amplification coefficient must be positive.");
  }
  x = x * reservePrecision;
  y = y * reservePrecision;
  a = a * aPrecision;
  const sum: bigint = x + y;
  if (sum === 0n) {
    return 0n;
  }

  let d = sum;
  const ann = a * 2n;
  for (let i = 0; i < 255; i++) {
    const d_p = (d * d * d) / (4n * x * y);
    const d_prev = d;

    d =
      (((ann * sum) / 100n + d_p * 2n) * d) /
      (((ann - 100n) * d) / 100n + 3n * d_p);

    if (d > d_prev) {
      if (d - d_prev <= 1) {
        if (liquidityInvariant(x, y, a / aPrecision, d)) {
          return d;
        } else {
          return d - 1n;
        }
      }
    } else {
      if (d_prev - d <= 1) {
        if (liquidityInvariant(x, y, a / aPrecision, d)) {
          return d;
        } else {
          return d - 1n;
        }
      }
    }
  }
  throw new Error("Failed to converge on D value after 255 iterations.");
}

export function getNewY(
  newX: bigint,
  aRaw: bigint,
  sumInvariant: bigint,
): bigint {
  newX = newX * reservePrecision;
  const sum = newX;
  let yPrev = 0n;
  let c = sumInvariant;
  const ann = aRaw * aPrecision * 2n;

  c = (c * sumInvariant) / (newX * 2n);
  c = (c * sumInvariant * aPrecision) / 2n;
  c = c / (ann * 2n);
  const b = sum + (sumInvariant * aPrecision) / 2n / ann;
  let y = sumInvariant;
  for (let i = 0; i < 255; i++) {
    yPrev = y;
    y = (y * y + c) / (y * 2n + b - sumInvariant);
    if (y > yPrev) {
      if (y - yPrev <= 1n) {
        if (liquidityInvariant(newX, y, aRaw, sumInvariant)) {
          return y;
        } else {
          return y + 1n;
        }
      }
    } else {
      if (yPrev - y <= 1n) {
        if (liquidityInvariant(newX, y, aRaw, sumInvariant)) {
          return y;
        } else {
          return y + 1n;
        }
      }
    }
  }
  throw new Error("failed to converge on y value after 255 iterations.");
}

/**
 * Get the lp token amount for a, b
 * @param a tokenA amount
 * @param b tokenB amount
 * @returns the minted lp token amount
 */
export const getFirstLp = (a: bigint, b: bigint, laf: bigint) =>
  getSumInvariant(laf, a, b);

/**
 * Calculate the Add (Mixed-Deposit) Liquidity parameters
 *
 * TODO: Investigate way to optimize actualdeposited amounts
 *
 * @param {bigint} a - The amount of token A to deposit.
 * @param {bigint} b - The amount of token B to deposit.
 * @param {bigint} aReserve - The current reserve of token A in the pool.
 * @param {bigint} bReserve - The current reserve of token B in the pool.
 * @param {bigint} totalLp - The total lp tokens for the pool before the deposit.
 * @param {bigint} laf - The linear amplifciation factor of the pool.
 * @throws {Error} If the pool doesn't have enough liquidity.
 * @throws {Error} If either of the deposit amounts is zero.
 * @returns {Object} An object containing:
 *   - nextTotalLp: The total lp tokens for the pool after the deposit.
 *   - generatedLp: The amount of lp tokens generated by the deposit.
 *   - shareAfterDeposit: The depositor's share of the pool after the deposit.
 */
export const calculateLiquidity = (
  a: bigint,
  b: bigint,
  aReserve: bigint,
  bReserve: bigint,
  totalLp: bigint,
  laf: bigint,
) => {
  if (aReserve === 0n && bReserve === 0n) {
    throw new Error("Not enough pool liquidity");
  }

  if (a === 0n && b === 0n) {
    throw new Error("Cannot use a deposit asset amount of 0");
  }

  const oldSumInvariant = getSumInvariant(laf, aReserve, bReserve);

  const newSumInvariant = getSumInvariant(laf, aReserve + a, bReserve + b);

  const newLpTokens =
    ((newSumInvariant - oldSumInvariant) * totalLp) / oldSumInvariant;

  const newTotalLpTokens = totalLp + newLpTokens;

  return {
    nextTotalLp: newTotalLpTokens,
    generatedLp: newLpTokens,
    shareAfterDeposit: SharedPoolMath.getShare(newLpTokens, newTotalLpTokens),
    aChange: 0n,
    bChange: 0n,
    actualDepositedA: a,
    actualDepositedB: b,
  };
};

/**
 * Get the token amounts the given lp represents
 * @param lp the lp amount
 * @param aReserve the pool's reserveA amount
 * @param bReserve the pool's reserveB amount
 * @param totalLp the pool's total minted lp currently
 * @returns [a, b] token amounts
 */
export const getTokensForLp = (
  lp: bigint,
  aReserve: bigint,
  bReserve: bigint,
  totalLp: bigint,
): SharedPoolMath.TPair => [
  new Fraction(lp * aReserve, totalLp).quotient,
  new Fraction(lp * bReserve, totalLp).quotient,
];

/**
 * Holds the calculated outcome of a swap
 */
export type TSwapOutcome = {
  input: bigint;
  output: bigint;
  outputLpFee: bigint;
  outputProtocolFee: bigint;
  nextInputReserve: bigint;
  nextOutputReserve: bigint;
  nextSumInvariant: bigint;
  priceImpact: Fraction;
};

/**
 * Calculate swap outcome for a given input and pool parameters (input tokens, output tokens, fee).
 * Throws if
 *  - any of the arguments are negative
 *  - fee is greater than or equal 1
 *
 * @param input The given amount of tokens to be swapped
 * @param inputReserve The amount of tokens in the input reserve
 * @param outputReserve The amount of tokens in the output reserve
 * @param fee The liquidity provider fee
 * @param protocolFee The protocol fee
 * @param laf The linear amplification factor
 * @returns The swap details
 */
export const getSwapOutput = (
  input: bigint,
  inputReserve: bigint,
  outputReserve: bigint,
  fee: TFractionLike,
  protocolFee: TFractionLike,
  laf: bigint,
  roundOutputUp?: boolean,
): TSwapOutcome => {
  if (input <= 0 || inputReserve <= 0 || outputReserve <= 0)
    throw new Error("Input and reserves must be positive");

  fee = Fraction.asFraction(fee);
  if (fee.lt(Fraction.ZERO) || fee.gte(Fraction.ONE))
    throw new Error("fee must be between 0 and 1");

  protocolFee = Fraction.asFraction(protocolFee);
  if (protocolFee.lt(Fraction.ZERO) || protocolFee.gte(Fraction.ONE))
    throw new Error("protocolFee must be between 0 and 1");

  const combinedFee = fee.add(protocolFee);
  if (combinedFee.gte(Fraction.ONE))
    throw new Error("Combined fee must be less than 1");

  const sumInvariant = getSumInvariant(laf, inputReserve, outputReserve);
  const nextInputReserve = inputReserve + input;
  const newY = getNewY(nextInputReserve, laf, sumInvariant);

  const deltaYPrec = outputReserve * reservePrecision - newY;
  const deltaY = new Fraction(deltaYPrec, reservePrecision);

  const totalFee = combinedFee.multiply(deltaY);
  const totalProtocolFee = protocolFee.multiply(deltaY);

  const totalLpFee = totalFee.quotient - totalProtocolFee.quotient;

  const output = deltaY.subtract(totalFee);
  const safeOutput = roundOutputUp
    ? (output.numerator + output.denominator - 1n) / output.denominator
    : output.quotient;
  const nextOutputReserve = outputReserve - safeOutput + totalLpFee;

  // PRICEIMPACT: "priceImpact" is slightly misleadingly named in the industry as a whole
  // just by it's name, it would imply that it's the percentage difference between
  // the current price and the price after the swap, but it's actually the percentage
  // difference between the real price of your swap, and the price implied by the current
  // reserves; We got this wrong in v1, but this aligns it with the industry standard
  // Source: https://dailydefi.org/articles/price-impact-and-how-to-calculate/
  const idealPrice = getPrice(inputReserve, outputReserve, laf);
  const actualPrice = new Fraction(input, safeOutput);
  const priceImpact = Fraction.ONE.subtract(idealPrice.divide(actualPrice));
  return {
    input,
    output: safeOutput,
    outputLpFee: totalLpFee,
    outputProtocolFee: totalProtocolFee.quotient,
    nextInputReserve,
    nextOutputReserve,
    nextSumInvariant: getSumInvariant(laf, nextInputReserve, nextOutputReserve),
    priceImpact,
  };
};

export function getPrice(
  aReserve: bigint,
  bReserve: bigint,
  laf: bigint,
  dA: bigint = 100n,
): Fraction {
  dA = aReserve <= dA ? aReserve - 1n : dA;
  const sumInvariant = getSumInvariant(laf, aReserve, bReserve);
  const lowY = getNewY(aReserve + dA, laf, sumInvariant);
  const highY = getNewY(aReserve - dA, laf, sumInvariant);
  return new Fraction(2n * dA * reservePrecision, highY - lowY);
}
